type=page
status=published
title=Using Jakarta Data Repositories
next=webapps.html
prev=jpa.html
~~~~~~

= Using Jakarta Data Repositories

[[using-jakarta-data-repositories]]
== Using Jakarta Data Repositories

This chapter describes how to use Jakarta Data repositories in {productName} applications. Jakarta Data provides a standard API for data access that simplifies database operations through repository interfaces and automatic query generation.

The following topics are addressed here:

* xref:#overview-of-jakarta-data[Overview of Jakarta Data]
* xref:#defining-repository-interfaces[Defining Repository Interfaces]
* xref:#nosql-entities-and-databases[NoSQL Entities and Databases]
* xref:#query-methods[Query Methods]
* xref:#custom-queries[Custom Queries]
* xref:#pagination-and-sorting[Pagination and Sorting]
* xref:#transaction-management[Transaction Management]
* xref:#jakarta-validation-support[Jakarta Validation Support]
* xref:#configuring-jakarta-data-repositories[Configuring Jakarta Data Repositories]
* xref:#integration-with-jpa[Integration with JPA]

For more information about Jakarta Data {jakarta-data-api-version}, see the official https://jakarta.ee/specifications/data/{jakarta-data-spec-version}[Jakarta Data {jakarta-data-api-version} documentation].

[[overview-of-jakarta-data]]

=== Overview of Jakarta Data

Jakarta Data is a specification that provides a standard API for data access in Jakarta EE applications. It offers a repository-based programming model that reduces boilerplate code and provides type-safe database operations.

Key features of Jakarta Data include:

* Repository interfaces with automatic implementation generation
* Query derivation from method names
* Support for custom queries using JDQL or JPQL
* Built-in pagination and sorting capabilities
* Integration with Jakarta Persistence (JPA) for relational databases
* Integration with Jakarta NoSQL for NoSQL databases
* Type-safe query building
* Support for both SQL and NoSQL databases in the same application

Jakarta Data repositories work by defining interfaces that may extend base repository types. The Jakarta Data provider automatically generates implementations of these interfaces at build time or runtime.

In {productName}, Jakarta Data is implemented using Eclipse JNoSQL, which provides:

* **Unified API** - The same repository interfaces for both SQL and NoSQL databases
* **Multi-database support** - Support for SQL, Document, Key-Value, Wide-Column, and Graph databases
* **JPA integration** - Seamless integration with existing JPA entities (for SQL databases)
* **NoSQL entities** - Support for Jakarta NoSQL entities (for NoSQL databases)
* **Automatic routing** - Automatic database detection and query creation based on entity type

[[defining-repository-interfaces]]

=== Defining Repository Interfaces

Jakarta Data repositories are defined as interfaces annotated with `@Repository` annotation (`@jakarta.data.Repository`). The interface may extend one of the base repository interfaces, which provide some ready-to-use methods:

* `Repository<T, K>` - Basic repository interface
* `CrudRepository<T, K>` - Adds CRUD operations
* `PageableRepository<T, K>` - Adds pagination support


[[basic-repository-example]]
=== Basic Repository Example

This example shows a simple repository interface that extends `CrudRepository` for a `Product` entity. It contains methods defined in `CrudRepository` as well as custom query methods using annotations and parameters.

[source,java]
----
import jakarta.data.repository.CrudRepository;
import jakarta.data.repository.Repository;
import jakarta.data.repository.Find;
import jakarta.data.repository.By;
import jakarta.data.repository.OrderBy;

@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

    // Parameter-based queries using @Find and @By annotations
    @Find
    List<Product> findProducts(@By("name") String name);

    @Query("WHERE price BETWEEN :minPrice AND :maxPrice")
    List<Product> findProductsByPriceRange(BigDecimal minPrice, BigDecimal maxPrice);

    @Find
    Optional<Product> findProduct(@By("code") String code);

    @Find
    @OrderBy("price")
    List<Product> findProducts(@By("category") String category);
}
----

[[alternative-method-name-based-queries]]
=== Alternative: Method Name-Based Queries (Deprecated)

{productName} also supports method name-based query derivation, but this approach is deprecated and might be removed in future versions. Use the annotated approach shown above instead.

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

    // Method names are automatically converted to queries (DEPRECATED)
    List<Product> findByName(String name);

    List<Product> findByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);

    Optional<Product> findByCode(String code);

    List<Product> findByCategoryOrderByPriceAsc(String category);
}
----

[[mixed-jpa-and-nosql-entity-usage]]
=== Mixed JPA and NoSQL Entity Usage

You can use both JPA entities and NoSQL entities in the same {productName} application. Define separate repository interfaces for each entity type, and configure the appropriate database connections as described above.

You cannot mix JPA entities and NoSQL entities in the same repository interface; each repository must be dedicated to a single entity type, and, in case of JPA, also to a single persistence unit.

[[entity-definition]]
==== Entity Definition

Your entity classes should be standard JPA entities:

[source,java]
----
import jakarta.persistence.*;

@Entity
@Table(name = "products")
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true)
    private String code;

    private String name;
    private String category;
    private BigDecimal price;

    // Constructors, getters, and setters
}
----

[[query-methods]]

=== Query Methods

Jakarta Data supports automatic query generation using annotated methods with the `@Find`, `@Count`, `@Exists`, and `@Delete` annotations combined with parameter annotations like `@By`.

[[supported-query-annotations]]
==== Supported Query Annotations

* `@Find` - Find operations
* `@Count` - Count operations
* `@Exists` - Existence checks
* `@Delete` - Delete operations
* `@Insert` - Insert operations
* `@Update` - Update operations
* `@Save` - Save operations (insert or update)

[[parameter-annotations]]
==== Parameter Annotations

* `@By("propertyName")` - Query by property. Specifies the entity property to query by, which can be nested to specify properties of referenced entities (e.g., `@By("customer.address.city")`). If the application is compiled with preserving parameter names in the bytecode (e.g., with `javac -parameters`), `@By` is optional and if not present, the property name will be derived from the parameter name.

[[examples]]
==== Examples

[source,java]
----
import jakarta.data.repository.*;

@Repository
public interface CustomerRepository extends CrudRepository<Customer, Long> {

    // Find by single property
    @Find
    List<Customer> findCustomers(@By("lastName") String lastName);

    // Multiple conditions with And (multiple @By parameters)
    @Find
    List<Customer> findCustomers(@By("firstName") String firstName, @By("lastName") String lastName);

    // Range queries using @Query with JDQL
    @Query("WHERE age BETWEEN :minAge AND :maxAge")
    List<Customer> findCustomersByAgeRange(int minAge, int maxAge);

    // Comparison operators using @Query with JDQL
    @Query("WHERE age > :age")
    List<Customer> findCustomersOlderThan(int age);

    // Pattern matching using @Query with JDQL
    @Query("WHERE email LIKE :pattern")
    List<Customer> findCustomersByEmailPattern(String pattern);

    // Collection operations using @Query with JDQL
    @Query("WHERE status IN :statuses")
    List<Customer> findCustomersByStatuses(Collection<String> statuses);

    // Null checks using default methods
    @Find
    List<Customer> findCustomers(@By("middleName") String middleName);

    default List<Customer> findCustomersWithNullMiddleName() {
        return findCustomers((String) null);
    }

    // Counting
    @Count
    long countCustomers(@By("status") String status);

    // Existence checks
    @Exists
    boolean customerExists(@By("email") String email);

    // Delete operations
    @Delete
    void deleteCustomers(@By("status") String status);

    // Insert operations
    @Insert
    Customer insertCustomer(Customer customer);

    @Insert
    List<Customer> insertCustomers(List<Customer> customers);

    // Update operations
    @Update
    Customer updateCustomer(Customer customer);

    @Update
    List<Customer> updateCustomers(List<Customer> customers);

    // Save operations (insert or update)
    @Save
    Customer saveCustomer(Customer customer);

    @Save
    List<Customer> saveCustomers(List<Customer> customers);
}
----

[[alternative-method-name-based-queries-deprecated]]
==== Alternative: Method Name-Based Queries (Deprecated)

{productName} also supports method name-based query derivation using a standardized naming convention, but this approach may be removed in future versions. Use the annotated approach shown above instead.

===== Supported Keywords

* `findBy`, `getBy`, `queryBy`, `readBy` - Find operations
* `countBy` - Count operations
* `existsBy` - Existence checks
* `deleteBy`, `removeBy` - Delete operations

===== Property Expressions

* `And`, `Or` - Logical operators
* `Between` - Range queries
* `LessThan`, `GreaterThan` - Comparison operators
* `Like`, `NotLike` - Pattern matching
* `In`, `NotIn` - Collection membership
* `IsNull`, `IsNotNull` - Null checks
* `True`, `False` - Boolean values

===== Examples

[source,java]
----
public interface CustomerRepository extends CrudRepository<Customer, Long> {

    // Find by single property
    List<Customer> findByLastName(String lastName);

    // Multiple conditions with And
    List<Customer> findByFirstNameAndLastName(String firstName, String lastName);

    // Or conditions
    List<Customer> findByFirstNameOrLastName(String name);

    // Comparison operators
    List<Customer> findByAgeGreaterThan(int age);
    List<Customer> findByAgeBetween(int minAge, int maxAge);

    // Pattern matching
    List<Customer> findByEmailLike(String pattern);

    // Collection operations
    List<Customer> findByStatusIn(Collection<String> statuses);

    // Null checks
    List<Customer> findByMiddleNameIsNull();

    // Counting
    long countByStatus(String status);

    // Existence checks
    boolean existsByEmail(String email);

    // Delete operations
    void deleteByStatus(String status);
}
----

[[custom-queries]]

=== Custom Queries

For complex queries that cannot be expressed through method names, Jakarta Data supports custom queries using the `@Query` annotation. Jakarta Data specifies its own query language called JDQL (Jakarta Data Query Language), which is similar to JPQL (Java Persistence Query Language). {productName} also supports full JPQL queries.

Examples:

[source,java]
----
import jakarta.data.repository.Query;

@Repository
public interface OrderRepository extends CrudRepository<Order, Long> {

    /* A JPQL query that selects orders by customer ID and status. JPQL allows omitting
     * the "SELECT o FROM Order o" part and by default operates on the entity returned
     * by the mothod (Order in this case).
     */
    @Query("WHERE customer.id = :customerId AND status = :status")
    List<Order> findOrdersByCustomerAndStatus(Long customerId, String status);

    /* A JPQL query that selects orders containing products from a specific category.
     * JPQL requires the full "SELECT o FROM Order o" syntax.
     */
    @Query("SELECT o FROM Order o JOIN o.items i WHERE i.product.category = :category")
    List<Order> findOrdersWithProductCategory(String category);

    /* A JPQL query that counts orders placed since a specific date.
     */
    @Query("SELECT COUNT(o) FROM Order o WHERE o.orderDate >= :startDate")
    long countOrdersSince(LocalDate startDate);
}
----

[[pagination-and-sorting]]

=== Pagination and Sorting

Jakarta Data provides built-in support for pagination and sorting through the `Pageable` and `Sort` interfaces.

==== Using Pageable

[source,java]
----
import jakarta.data.repository.Pageable;
import jakarta.data.repository.Page;
import jakarta.data.repository.Sort;
import jakarta.data.repository.Find;
import jakarta.data.repository.By;

@Repository
public interface ProductRepository extends PageableRepository<Product, Long> {

    @Find
    Page<Product> findProducts(@By("category") String category, Pageable pageable);

    @Query("WHERE price > :price")
    List<Product> findProductsAbovePrice(BigDecimal price, Sort sort);
}
----

==== Usage Example

[source,java]
----
@Inject
private ProductRepository productRepository;

public void demonstratePagination() {
    // Create pageable request for page 0, size 10, sorted by name
    Pageable pageable = Pageable.of(0, 10, Sort.by("name").ascending());

    Page<Product> page = productRepository.findProducts("Electronics", pageable);

    List<Product> products = page.getContent();
    long totalElements = page.getTotalElements();
    int totalPages = page.getTotalPages();
    boolean hasNext = page.hasNext();
}
----

[[transaction-management]]

=== Transaction Management

Jakarta Data repositories integrate with Jakarta EE transaction management. Repository methods automatically participate in existing transactions or create new ones as needed.

NOTE: Transaction management is not supported for NoSQL Data repositories yet. See xref:#limitations-of-nosql-data-repositories[limitations].

[[declarative-transactions]]
==== Declarative Transactions

[source,java]
----
import jakarta.ejb.Stateless;
import jakarta.transaction.Transactional;

@ApplicationScoped
public class OrderService {

    @Inject
    private OrderRepository orderRepository;

    @Inject
    private ProductRepository productRepository;

    @Transactional
    public Order createOrder(OrderRequest request) {
        // All repository operations participate in the same transaction
        Product product = productRepository.findById(request.getProductId())
            .orElseThrow(() -> new IllegalArgumentException("Product not found"));

        Order order = new Order();
        order.setProduct(product);
        order.setQuantity(request.getQuantity());
        order.setCustomerId(request.getCustomerId());

        return orderRepository.save(order);
    }
}
----

[[custom-transaction-behavior]]
==== Custom Transaction Behavior

[source,java]
----
@Repository
public interface AuditRepository extends CrudRepository<AuditLog, Long> {

    @Transactional(Transactional.TxType.REQUIRES_NEW)
    AuditLog save(AuditLog auditLog);
}
----

By default, repository methods use `REQUIRED` transaction type, which means they will join an existing transaction or create a new one if none exists. You can override this behavior using the `@Transactional` annotation on repository methods.

The @Transactional annotation can be applied to the repository interface or individual methods to specify custom transaction behavior.

[[jakarta-validation-support]]

=== Jakarta Validation Support

Jakarta Data repositories integrate with Jakarta Validation to validate method parameters and return values. To trigger validation, repository method parameters need to be annotated with validation annotations.

NOTE: Validation is not supported for NoSQL Data repositories yet. See xref:#limitations-of-nosql-data-repositories[limitations].

[[parameter-validation]]
==== Parameter Validation

For simple field validation, use annotations like `@Max`, `@Min`, `@NotNull` directly on parameters:

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

    @Find
    List<Product> findProducts(@By("price") @Max(1000) @Min(0) BigDecimal maxPrice);

    @Find
    List<Product> findProducts(@By("category") @NotBlank String category);
}
----

For entities that contain validation annotations on their fields, use `@Valid` on the parameter:

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

    @Insert
    Product insertProduct(@Valid Product product);

    @Update
    Product updateProduct(@Valid Product product);

    @Save
    Product saveProduct(@Valid Product product);

    @Insert
    List<Product> insertProducts(@Valid List<Product> products);
}
----

[[entity-validation-annotations]]
==== Entity Validation Annotations

Define validation rules on your entity fields:

[source,java]
----
@Entity
@Table(name = "products")
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Product code is required")
    @Size(max = 20, message = "Product code must not exceed 20 characters")
    private String code;

    @NotBlank(message = "Product name is required")
    @Size(max = 100, message = "Product name must not exceed 100 characters")
    private String name;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    private BigDecimal price;

    @Min(value = 0, message = "Stock quantity cannot be negative")
    private Integer stockQuantity;

    // Constructors, getters, and setters
}
----

[[method-return-value-validation]]
==== Method Return Value Validation

Validation annotations can also be applied to methods to validate return values:

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

    @Find
    @NotNull
    Optional<Product> findProduct(@By("code") String code);

    @Find
    @Size(min = 1, message = "At least one product must be found")
    List<Product> findProducts(@By("category") String category);
}
----

[[handling-validation-errors]]
==== Handling Validation Errors

Validation errors are thrown as `ConstraintViolationException`:

[source,java]
----
@ApplicationScoped
public class ProductService {

    @Inject
    private ProductRepository productRepository;

    public Product createProduct(Product product) {
        try {
            return productRepository.insertProduct(product);
        } catch (ConstraintViolationException e) {
            Set<ConstraintViolation<?>> violations = e.getConstraintViolations();
            for (ConstraintViolation<?> violation : violations) {
                String property = violation.getPropertyPath().toString();
                String message = violation.getMessage();
                System.err.println("Validation error on " + property + ": " + message);
            }
            throw e;
        }
    }
}
----

[[configuring-jpa-data-repositories]]

=== Configuring Data Repositories for JPA entities

To use Jakarta Data repositories for JPA entities in your {productName} application, you need to:

1. **Add API to compiler's classpath:** Addthe Jakarta Data API or Jakarta EE API dependency to your project
2. **Link to a database connection:** Configure a Jakarta Persistence persistence unit
3. **Install database driver:** Either use the default datasource or configure a custom data source and install a JDBC driver for your database.


[[adding-dependencies]]
==== Adding Dependencies

Add the Jakarta Data API dependency to your `pom.xml`:

[source,xml,subs="specialchars,attributes"]
----
<dependency>
    <groupId>jakarta.data</groupId>
    <artifactId>jakarta.data-api</artifactId>
    <version>{jakarta-data-api-version}</version>
</dependency>
----

Alternatively, if you're using the full Jakarta EE platform, you can use:

[source,xml,subs="specialchars,attributes"]
----
<dependency>
    <groupId>jakarta.platform</groupId>
    <artifactId>jakarta.jakartaee-api</artifactId>
    <version>{jakarta-platform-version}</version>
    <scope>provided</scope>
</dependency>
----

[[connect-to-jakarta-persistence-persistence-unit-for-jpa-entities]]
==== Connect to Jakarta Persistence persistence unit (for JPA Entities)

By default, Data repositories for JPA entities use the default JPA persistence unit source configured in {productName}.

Configure the default Jakarta Persistence persistence unit in your `persistence.xml`:

[source,xml]
----
<persistence-unit transaction-type="JTA">
    <class>com.example.model.Product</class>
    <properties>
        <property name="jakarta.persistence.schema-generation.database.action" value="create"/>
    </properties>
</persistence-unit>
----

This will use the default data source configured in {productName}, which points to a Derby database. Make sure that DerbyDB is running if you use the default datasource. You can start the Derby database using the xref:reference-manual.adoc#start-database[`start-database`] command. If you want to specify a custom data source, see the next section.

[[data-source-configuration-for-jpa-optional-but-recommended]]
==== Data Source Configuration for JPA (Optional but recommended)

If you need to configure a custom data source for JPA entities, use the {productName} administration console or the `asadmin` CLI command, with xref:reference-manual.adoc#create-jdbc-connection-pool[`create-jdbc-connection-pool`] and xref:reference-manual.adoc#create-jdbc-resource[`create-jdbc-resource`] commands, and appropriate JDBC driver installed in {productName}:

[source,bash]
----
asadmin create-jdbc-connection-pool --datasourceclassname org.postgresql.ds.PGSimpleDataSource \
  --restype javax.sql.DataSource \
  --property user=myuser:password=mypassword:databaseName=mydb:serverName=localhost:port=5432 \
  MyPool

asadmin create-jdbc-resource --connectionpoolid MyPool jdbc/MyDataSource
----

The above example uses PostgreSQL database. Adjust the `datasourceclassname` and properties according to your database and JDBC driver. For information on how to install JDBC drivers in {productName}, see xref:administration-guide.adoc#jdbc[Administering Database Connectivity].

Then adjust your `persistence.xml` to reference the custom data source by its JNDI name defined by the create-jdbc-resource command earlier:

[source,xml]
----
<persistence-unit name="myPU" transaction-type="JTA">
    <jta-data-source>jdbc/MyDataSource</jta-data-source>
    <class>com.example.model.Product</class>
    <properties>
        <property name="jakarta.persistence.schema-generation.database.action" value="create"/>
    </properties>
</persistence-unit>
----

[[retrieve-entitymanager-in-default-methods]]
==== Retrieve EntityManager in default methods

You can access the EntityManager used by the repository using a method in the repository interface that returns EntityManager. This allows you to implement custom default repository methods that use the EntityManager directly.

Example:

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

    // Method to access the repository's EntityManager
    EntityManager getEntityManager();

    // Custom method using the repository's EntityManager
    default List<Product> findProductsWithComplexLogic(String searchTerm) {
        EntityManager em = getEntityManager();
        return em.createQuery(
            "SELECT p FROM Product p WHERE p.name LIKE :term OR p.description LIKE :term",
            Product.class)
            .setParameter("term", "%" + searchTerm + "%")
            .getResultList();
    }
}
----

[[entitymanager-configuration]]
==== EntityManager Configuration

By default, Jakarta Data repositories use the default EntityManager as if it's injected via `@Inject EntityManager`.

You can use a specific `EntityManager` by one of the following methods:

* Specify the persistence unit name in the `@Repository` annotation
* Specify CDI qualifiers on a method to select a specific `EntityManager`
* Create a custom default method that returns an `EntityManager`

===== Specifying Persistence Unit

To use a specific persistence unit, set the `dataStore` attribute in the `@Repository` annotation to the name of the persistence unit defined in `persistence.xml`.

===== Specifying CDI Qualifiers on a method

A custom EntityManager can be specified using a repository method that returns EntityManager. Such method should be annotated by CDI qualifiers that should be used to retrieve the EntityManager. The implementation of the method will also return this EntityManager when called in the application.

If a single repository contains several methods that return EntityManager, calling repository methods will throw an exception.


[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

    // Method to access the repository's EntityManager
    @CustomDB
    EntityManager getEntityManager();

}
----

===== Custom method that returns EntityManager

To specify a custom EntityManager programmatically, define a default method in the repository interface that returns an EntityManager. You can use CDI programmatically to inject the desired EntityManager.

[source,java]
----
@Repository
public interface ProductRepository extends CrudRepository<Product, Long> {

    // Method to provide a custom EntityManager to the repository
    default EntityManager getEntityManager() {
        return CDI.current().select(EntityManager.class, new CustomDB.Literal()).get();
    }

}
----

[[mixing-repositories-and-jpa-entitymanager]]
==== Mixing JPA repositories and JPA EntityManager

The following cases will use the same persistence context:

* Calling repository methods
* Using EntityManager retrieved from the repository
* Using an injected EntityManager for the same persistence unit defined for the repository

You can freely mix Jakarta Data repository methods and direct EntityManager operations in the same application, even in the same transaction. As long as the EntityMangers are for the same persistence unit, they will share the same persistence context. If they are for different persistence units, they will operate independently and will require XA datasources if used in the same transaction.

[source,java]
----
@ApplicationScoped
@Transactional
public class CustomerService {

    @Inject
    private EntityManager entityManager;

    @Inject
    private CustomerRepository customerRepository;

    public Customer updateCustomerWithAudit(Long customerId, CustomerUpdate update) {

        EntityManager repositoryEntityManager = customerRepository.getEntityManager();

        // Use repository for simple operations
        Customer customer = customerRepository.findById(customerId)
            .orElseThrow(() -> new EntityNotFoundException("Customer not found"));

        // Use EntityManager for complex operations
        AuditLog audit = new AuditLog();
        audit.setAction("UPDATE_CUSTOMER");
        audit.setEntityId(customerId);
        audit.setTimestamp(LocalDateTime.now());
        entityManager.persist(audit);

        // Alternatively, use the repository's EntityManager to ensure the same persistence context
        repositoryEntityManager.flush();

        // Update using repository
        customer.setName(update.getName());
        customer.setEmail(update.getEmail());

        return customerRepository.save(customer);
    }
}
----

[[configuring-nosql-data-repositories]]
=== Configuring Data Repositories for NoSQL Entities

To use Jakarta Data repositories for NoSQL entities in your {productName} application, you need to:

1. **Add API to compiler's classpath:** Addthe Jakarta Data API or Jakarta EE API dependency to your project
2. **Link to a database connection:** Configure properties of the NoSQL database connection
3. **Install database driver:** Install JNoSQL driver for your database and configure database type

[[nosql-database-categories]]
==== NoSQL Database Categories

Eclipse JNoSQL supports four main categories of NoSQL databases:

**Document Databases**

Document databases store data in document format, typically JSON or BSON. Each document can have its own structure, providing flexibility in data modeling.

* **Examples:** MongoDB, CouchDB, CouchBase, ArangoDB
* **Use cases:** Content management, catalogs, user profiles
* **Data structure:** Nested documents with complex hierarchies

**Key-Value Databases**

Key-Value databases are the simplest NoSQL databases, storing data as key-value pairs.

* **Examples:** Redis, Hazelcast, Memcached, Riak
* **Use cases:** Caching, session storage, shopping carts
* **Data structure:** Simple key-value pairs

**Wide-Column Databases**

Wide-Column databases store data in column families, allowing for flexible schemas and high scalability.

* **Examples:** Cassandra, HBase, DynamoDB
* **Use cases:** Time-series data, IoT applications, analytics
* **Data structure:** Column families with dynamic columns

**Graph Databases**

Graph databases store data as nodes and relationships, optimized for traversing connections.

* **Examples:** Neo4j, ArangoDB, OrientDB
* **Use cases:** Social networks, recommendation engines, fraud detection
* **Data structure:** Nodes connected by relationships

[[nosql-entity-annotations]]
==== NoSQL Entity Annotations

NoSQL entities use Jakarta NoSQL annotations, which are similar to JPA annotations:

[cols="30%,70%"]
|===
|Annotation |Description

|`@jakarta.nosql.Entity`
|Specifies that the class is a NoSQL entity

|`@jakarta.nosql.Id`
|Specifies the primary key of the entity

|`@jakarta.nosql.Column`
|Maps a field to a database column/attribute

|`@jakarta.nosql.Convert`
|Specifies a converter for the field

|`@jakarta.nosql.Embeddable`
|Specifies that the class is embeddable

|`@jakarta.nosql.Inheritance`
|Specifies inheritance mapping strategy for entities

|`@jakarta.nosql.DiscriminatorColumn`
|Specifies the discriminator column for the inheritance mapping strategy

|`@jakarta.nosql.DiscriminatorValue`
|Specifies the discriminator value for the inheritance mapping strategy

|`@jakarta.nosql.MappedSuperclass`
|Specifies a class whose mapping information is applied to entities that inherit from it.

|===

Notable differences between JPA and NoSQL annotations:

* NoSQL entities do not use `@Table` annotation; the collection/table name is specified by the entity name in the `@Entity` annotation.
* NoSQL entities do not support relationships (`@OneToMany`, `@ManyToOne`, etc.); related data should be embedded or referenced manually.
* There's no `@GeneratedValue` annotation; primary keys must be assigned manually or generated using application logic.
* There's no `@Version` annotation for optimistic locking; NoSQL databases typically handle concurrency differently.
* There's no `@Transient` annotation; all non-annotated fields are ignored by default.
* There's no `@Embedded` annotation; all embedded objects marked with `@Embeddable` are embedded automatically.
* Java `record` types are supported as NoSQL entities for read-only operations. Constructor arguments can be annotated as fiels with `@Id` and `@Column`. 

[[nosql-entity-examples]]
==== NoSQL Entity Examples

Entity mapped as a Java class, with the `address` field mapped as an embeddable class. 

[source,java]
----
import jakarta.nosql.Entity;
import jakarta.nosql.Id;
import jakarta.nosql.Column;

@Entity("customers")
public class Customer {

    @Id
    private String id;

    @Column
    private String name;

    @Column
    private String email;

    @Column
    private Address address; // Embedded object

    @Column
    private List<String> tags;

    @Column
    private Map<String, Object> metadata;

    // Constructors, getters, and setters
}

@Embeddable
public class Address {
    @Column
    private String street;
    
    @Column
    private String city;
    
    @Column
    private String country;
    
    // Constructors, getters, and setters
}
----

Entity mapped as a Java record, can only be used in read-only operations.

[source,java]
----
@Entity("sensor_data")
public record SensorReading(
    @Id String id,
    @Column String sensorId,
    @Column LocalDateTime timestamp,
    @Column Double temperature,
    @Column Double humidity,
    @Column Map<String, Double> additionalMetrics
) {}
----


[[repository-usage-with-nosql-entities]]
==== Repository Usage with NoSQL Entities

NoSQL entities work with the same repository interfaces as JPA entities:

[source,java]
----
@Repository
public interface CustomerRepository extends CrudRepository<Customer, String> {

    @Find
    List<Customer> findCustomers(@By("name") String name);

    @Find
    List<Customer> findCustomers(@By("address.city") String city);

    @Query("WHERE tags IN :tags")
    List<Customer> findCustomersByTags(List<String> tags);

    @Count
    long countCustomers(@By("address.country") String country);
}

@Repository
public interface SensorReadingRepository extends CrudRepository<SensorReading, String> {

    @Find
    List<SensorReading> findBySensorId(@By("sensorId") String sensorId);

    @Query("WHERE timestamp BETWEEN :start AND :end")
    List<SensorReading> findByTimestampRange(LocalDateTime start, LocalDateTime end);

    @Count
    long countBySensorId(@By("sensorId") String sensorId);
}
----




[[configuring-nosql-databases]]
==== Configuring NoSQL Databases

{productName} supports NoSQL databases through Eclipse JNoSQL. Eclipse JNoSQL provides support for four main NoSQL database categories:

* **Document databases** - Store data in document format (JSON/BSON)
* **Key-Value databases** - Simple key-value storage
* **Wide-Column databases** - Column-family storage
* **Graph databases** - Graph-based data storage

===== Supported NoSQL Databases

Eclipse JNoSQL supports the following NoSQL databases:

**Document Databases:**
* MongoDB
* CouchDB
* CouchBase
* OrientDB
* ArangoDB
* RavenDB
* Elasticsearch
* Solr

**Key-Value Databases:**
* Redis
* Hazelcast
* Infinispan
* Memcached
* Riak
* Oracle NoSQL
* ArangoDB

**Wide-Column Databases:**
* Cassandra
* HBase
* DynamoDB

**Graph Databases:**
* Neo4j
* OrientDB
* ArangoDB
* TinkerPop-compatible databases

For an up-to-date list of supported NoSQL databases and instructions on how to install drivers for specific databases, see the https://github.com/eclipse-jnosql/jnosql-databases/[Eclipse JNoSQL Databases] repository.

NOTE: **{productName} does not bundle NoSQL database drivers.** You need to add the appropriate Eclipse JNoSQL database dependency to your project or add it to the {productName} installation to use a specific NoSQL database. Some drivers also require parts of JNoSQL that are not included in {productName} by default, so make sure to add those dependencies as well. It's recommended to add NoSQL database driver artifact to your project as a runtime dependency so that the build tool (Maven, Gradle, etc.) bundles all transitive dependencies into your application. If you decide to add the driver to {productName} installation instead, make sure to also install all required transitive dependencies.


===== NoSQL Entity Definition

NoSQL entities use Jakarta NoSQL annotations, which are similar to JPA annotations:

[source,java]
----
import jakarta.nosql.Entity;
import jakarta.nosql.Id;
import jakarta.nosql.Column;

@Entity("products")
public class Product {

    @Id
    private String id;

    @Column
    private String name;

    @Column
    private String category;

    @Column
    private BigDecimal price;

    @Column
    private List<String> tags;

    // Constructors, getters, and setters
}
----

===== NoSQL Database Configuration

NoSQL database connections are configured using MicroProfile Config properties. The configuration varies by database type and specific database. 

NOTE: For more information about MicroProfile Config, see the https://microprofile.io/specifications/microprofile-config/[MicroProfile Config specification].

**MongoDB Configuration Example:**

To configure MongoDB connection, add the following properties to your `microprofile-config.properties` file (or equivalent configuration source):

[source,properties]
----
# Document database configuration
jnosql.document.database=mystore
jnosql.mongodb.host=localhost:27017
jnosql.mongodb.user=myuser
jnosql.mongodb.password=mypassword
----

MongoDB is a document database, so the `jnosql.document.database` property is used to specify the database name.

All other properties are specific to MongoDB connection. The following MongoDB-specific properties are supported:

jnosql.mongodb.host::
    The MongoDB server hostname or IP address, and port.
    Default: localhost:27017

jnosql.mongodb.user::
    The username for MongoDB authentication.

jnosql.mongodb.password::
    The password for MongoDB authentication.

jnosql.mongodb.authentication.source::
    The source where the user is defined.

jnosql.mongodb.authentication.mechanism::
    Authentication mechanism to use, one of the values of the `com.mongodb.AuthenticationMechanism` enum. See the MongoDB JavaDoc Documentation for the list of values.

NOTE: You can also provide the configuration values programmatically, by creating a custom MongoDBDocumentManagerSupplier. See the xref:#programmatic-configuration[Programmatic Configuration] section for an example.


===== Common Configuration Properties

Most NoSQL databases support these common configuration properties:

[cols="30%,70%"]
|===
|Property |Description

|`jnosql.<type>.provider`
|The fully qualified class name of the database configuration provider

|`jnosql.<type>.database`
|The database name or identifier

|`jnosql.<database>.host`
|The database host and port (format: host:port)

|`jnosql.<database>.user`
|The username for authentication

|`jnosql.<database>.password`
|The password for authentication

|`jnosql.<database>.timeout`
|Connection timeout in milliseconds
|===

Where `<type>` is one of: `document`, `keyvalue`, `column`, `graph` and `<database>` is the specific database name (e.g., `mongodb`, `redis`, `cassandra`).

===== Adding NoSQL Database Dependencies

To use a specific NoSQL database, add the corresponding Eclipse JNoSQL database dependency:

**MongoDB:**
[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.databases</groupId>
    <artifactId>jnosql-mongodb</artifactId>
    <version>{jnosql-version}</version>
</dependency>
----

**Redis:**
[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.databases</groupId>
    <artifactId>jnosql-redis</artifactId>
    <version>{jnosql-version}</version>
</dependency>
----

**Cassandra:**
[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.databases</groupId>
    <artifactId>jnosql-cassandra</artifactId>
    <version>{jnosql-version}</version>
</dependency>
----

**Neo4j:**
[source,xml]
----
<dependency>
    <groupId>org.eclipse.jnosql.databases</groupId>
    <artifactId>jnosql-neo4j</artifactId>
    <version>{jnosql-version}</version>
</dependency>
----

===== Programmatic Configuration

You can also configure NoSQL databases programmatically by creating a configuration supplier. For example, to configure MongoDB programmatically, create a class that implements `Supplier<DocumentManager>` and annotate it with `@Alternative` and `@Priority` to override the default configuration:

[source,java]
----
@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class MongoDBManagerSupplier implements Supplier<DocumentManager> {

    @Produces
    public DocumentManager get() {
        Settings settings = Settings.builder()
            .put("jnosql.mongodb.host", "localhost:27017")
            .put("jnosql.document.database", "mystore")
            .build();
        
        MongoDBDocumentConfiguration configuration = new MongoDBDocumentConfiguration();
        DocumentManagerFactory factory = configuration.apply(settings);
        return factory.apply("mystore");
    }
}
----

[[limitations-of-nosql-data-repositories]]
==== Limitations of NoSQL Data Repositories

When using NoSQL entities and repositories in {productName}, there are some limitations to be aware of:

===== Single NoSQL Database per Application

{productName} supports only one NoSQL database in a single application. You cannot use multiple different NoSQL databases (e.g., MongoDB and Redis) simultaneously in the same application instance.

===== Jakarta Validation Not Supported in NoSQL Repositories

Jakarta Validation is not yet supported in NoSQL Data repositories. Validation annotations on NoSQL entities and repository method parameters will be ignored.

For NoSQL entities, you must implement validation logic manually in your application code or service layer.

**Example:**

[source,java]
----
@Entity("products")
public class NoSQLProduct {

    @Id
    private String id;

    @Column
    private String name; // Validation annotations are ignored

    @Column
    private BigDecimal price; // Validation annotations are ignored
}

@Repository
public interface NoSQLProductRepository extends CrudRepository<NoSQLProduct, String> {

    @Find
    // Validation annotations on parameters are ignored
    NoSQLProduct findByName(@By("name") @NotBlank String name);
}

// Manual validation in service layer
@ApplicationScoped
public class NoSQLProductService {

    @Inject
    private NoSQLProductRepository repository;

    public NoSQLProduct createProduct(NoSQLProduct product) {
        // Implement validation manually
        if (product.getName() == null || product.getName().isBlank()) {
            throw new IllegalArgumentException("Product name is required");
        }
        if (product.getPrice() == null || product.getPrice().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Product price must be greater than zero");
        }

        return repository.save(product);
    }
}
----

JPA repositories for relational databases support Jakarta Validation as described in the xref:#jakarta-validation-support[Jakarta Validation Support] section.

===== JTA Transaction Support Not Yet Available for NoSQL Repositories

Jakarta Transactions (JTA) integration is not yet supported for NoSQL Data repositories. Calling repository methods within a JTA transaction or annotating the repository interface with `@Transactional` will not execute NoSQL queries within a transaction context.

You must manage transactions manually in your application code if needed, depending on the capabilities of the specific NoSQL database.

JPA repositories for relational databases support JTA transactions as described in the xref:#transaction-management[Transaction Management] section.
